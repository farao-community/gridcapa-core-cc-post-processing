/*
 * Copyright (c) 2023, RTE (http://www.rte-france.com)
 *  This Source Code Form is subject to the terms of the Mozilla Public
 *  License, v. 2.0. If a copy of the MPL was not distributed with this
 *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package com.farao_community.farao.core_cc_post_processing.app;

import com.farao_community.farao.core_cc_post_processing.app.exception.CoreCCPostProcessingInternalException;
import com.farao_community.farao.core_cc_post_processing.app.outputs.rao_response.ResponseMessageType;
import com.farao_community.farao.core_cc_post_processing.app.services.*;
import com.farao_community.farao.core_cc_post_processing.app.util.*;
import com.powsybl.openrao.data.craccreation.creator.fbconstraint.xsd.FlowBasedConstraintDocument;
import com.farao_community.farao.gridcapa.task_manager.api.ProcessFileDto;
import com.farao_community.farao.gridcapa.task_manager.api.ProcessFileStatus;
import com.farao_community.farao.gridcapa.task_manager.api.TaskDto;
import com.farao_community.farao.gridcapa_core_cc.api.resource.CoreCCMetadata;
import com.farao_community.farao.minio_adapter.starter.MinioAdapter;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static com.farao_community.farao.core_cc_post_processing.app.util.RaoMetadata.*;

/**
 * @author Philippe Edwards {@literal <philippe.edwards at rte-france.com>}
 * @author Godelaine de Montmorillon {@literal <godelaine.demontmorillon at rte-france.com>}
 */
@Service
public class PostProcessingService {
    private static final Logger LOGGER = LoggerFactory.getLogger(PostProcessingService.class);
    public static final String CORE_CC = "CORE/CC/";
    public static final String OUTPUTS_DIR = "RAO_OUTPUTS_DIR/";
    private final MinioAdapter minioAdapter;
    private RaoMetadata raoMetadata = new RaoMetadata();

    public PostProcessingService(MinioAdapter minioAdapter) {
        this.minioAdapter = minioAdapter;
    }

    public void processTasks(LocalDate localDate, Set<TaskDto> tasksToPostProcess, List<byte[]> logList) {
        String outputsTargetMinioFolder = generateTargetMinioFolder(localDate);
        // Fetch hourly outputs generated by core-cc runner
        Map<TaskDto, ProcessFileDto> cnePerTask = new HashMap<>();
        Map<TaskDto, ProcessFileDto> cgmPerTask = new HashMap<>();
        Map<TaskDto, ProcessFileDto> metadataPerTask = new HashMap<>();
        Map<TaskDto, ProcessFileDto> raoResultPerTask = new HashMap<>();
        fillMapsOfOutputs(tasksToPostProcess, cnePerTask, cgmPerTask, metadataPerTask, raoResultPerTask);

        // Generate outputs
        // Rao Result files to one zip
        zipRaoResultsAndSendToOutputs(outputsTargetMinioFolder, raoResultPerTask, localDate);
        // -- F341 : metadata file
        Map<TaskDto, CoreCCMetadata> metadataMap = fetchMetadataFromMinio(metadataPerTask);
        try {
            // Only write metadata for timestamps with a RaoRequestInstant defined
            uploadF341ToMinio(outputsTargetMinioFolder,
                CoreCCMetadataGenerator.generateMetadataCsv(metadataMap.values().stream()
                        .filter(metadata -> Objects.nonNull(metadata.getRaoRequestInstant()))
                        .toList(), raoMetadata).getBytes());
        } catch (Exception e) {
            LOGGER.error("Could not generate metadata file", e);
            throw new CoreCCPostProcessingInternalException("Could not generate metadata file", e);
        }

        // -- F342 : zipped logs
        zipAndUploadLogs(logList, NamingRules.generateZippedLogsName(raoMetadata.getRaoRequestInstant(), outputsTargetMinioFolder, raoMetadata.getVersion()));

        // -- F304 : cgms
        zipCgmsAndSendToOutputs(outputsTargetMinioFolder, cgmPerTask, localDate, raoMetadata.getCorrelationId(), raoMetadata.getTimeInterval());
        // -- F299 : cnes
        zipCnesAndSendToOutputs(outputsTargetMinioFolder, cnePerTask, localDate);
        // -- F303 : flowBasedConstraintDocument
        uploadF303ToMinio(new DailyF303Generator(minioAdapter).generate(raoResultPerTask, cgmPerTask), outputsTargetMinioFolder, localDate);
        // -- F305 : RaoResponse
        uploadF305ToMinio(outputsTargetMinioFolder, F305XmlGenerator.generateRaoResponse(tasksToPostProcess, localDate, raoMetadata.getCorrelationId(), metadataMap, raoMetadata.getTimeInterval()), localDate);
        LOGGER.info("All outputs were uploaded");
    }

    private String generateTargetMinioFolder(LocalDate localDate) {
        return OUTPUTS_DIR + localDate;
    }

    private void fillMapsOfOutputs(Set<TaskDto> tasksToProcess,
                                   Map<TaskDto, ProcessFileDto> cnes,
                                   Map<TaskDto, ProcessFileDto> cgms,
                                   Map<TaskDto, ProcessFileDto> metadatas,
                                   Map<TaskDto, ProcessFileDto> raoResults) {
        tasksToProcess.forEach(taskDto ->
            taskDto.getOutputs().forEach(processFileDto -> {
                switch (processFileDto.getFileType()) {
                    case "CNE":
                        cnes.put(taskDto, processFileDto);
                        break;
                    case "CGM_OUT":
                        cgms.put(taskDto, processFileDto);
                        break;
                    case "METADATA":
                        metadatas.put(taskDto, processFileDto);
                        break;
                    case "RAO_RESULT":
                        raoResults.put(taskDto, processFileDto);
                        break;
                    default:
                        // do nothing, other outputs are available but we won't be collecting them
                }
            })
        );
    }

    private Map<TaskDto, CoreCCMetadata> fetchMetadataFromMinio(Map<TaskDto, ProcessFileDto> metadatas) {
        Map<TaskDto, CoreCCMetadata> metadataMap = new HashMap<>();
        metadatas.entrySet().stream().filter(md -> md.getValue().getProcessFileStatus().equals(ProcessFileStatus.VALIDATED)).
            forEach(metadata -> {
                InputStream inputStream = minioAdapter.getFileFromFullPath(metadata.getValue().getFilePath());
                try {
                    CoreCCMetadata coreCCMetadata = new ObjectMapper().readValue(IOUtils.toString(inputStream, StandardCharsets.UTF_8), CoreCCMetadata.class);
                    metadataMap.put(metadata.getKey(), coreCCMetadata);
                } catch (IOException e) {
                    throw new CoreCCPostProcessingInternalException("error while fetching individual metadata", e);
                }
            });
        // Sanity checks
        if (metadataMap.values().stream().map(CoreCCMetadata::getTimeInterval).collect(Collectors.toSet()).size() > 1) {
            throw new CoreCCPostProcessingInternalException("Wrong time Interval in metadata");
        }
        if (metadataMap.values().stream().map(CoreCCMetadata::getRaoRequestFileName).collect(Collectors.toSet()).size() > 1) {
            throw new CoreCCPostProcessingInternalException("Wrong Rao request file name in metadata");
        }
        if (metadataMap.values().stream().map(CoreCCMetadata::getVersion).collect(Collectors.toSet()).size() > 1) {
            throw new CoreCCPostProcessingInternalException("Wrong version in metadata");
        }
        if (metadataMap.values().stream().map(CoreCCMetadata::getCorrelationId).collect(Collectors.toSet()).size() > 1) {
            throw new CoreCCPostProcessingInternalException("Wrong correlationId in metadata");
        }
        // Define raoMetadata attributes
        raoMetadata.setStatus(generateOverallStatus(metadataMap.values().stream().map(CoreCCMetadata::getStatus).collect(Collectors.toSet())));
        raoMetadata.setTimeInterval(metadataMap.values().stream().map(CoreCCMetadata::getTimeInterval).collect(Collectors.toSet()).iterator().next());
        raoMetadata.setRequestReceivedInstant(getFirstInstant(metadataMap.values().stream().map(CoreCCMetadata::getRequestReceivedInstant).collect(Collectors.toSet())));
        raoMetadata.setRaoRequestFileName(metadataMap.values().stream().map(CoreCCMetadata::getRaoRequestFileName).collect(Collectors.toSet()).iterator().next());
        raoMetadata.setVersion(metadataMap.values().stream().map(CoreCCMetadata::getVersion).collect(Collectors.toSet()).iterator().next());
        raoMetadata.setCorrelationId(metadataMap.values().stream().map(CoreCCMetadata::getCorrelationId).collect(Collectors.toSet()).iterator().next());
        raoMetadata.setOutputsSendingInstant(Instant.now().toString());
        // The following metadata can be null
        raoMetadata.setComputationStartInstant(getFirstInstant(metadataMap.values().stream().map(CoreCCMetadata::getComputationStart).filter(Objects::nonNull).collect(Collectors.toSet())));
        raoMetadata.setComputationEndInstant(getLastInstant(metadataMap.values().stream().map(CoreCCMetadata::getComputationEnd).filter(Objects::nonNull).collect(Collectors.toSet())));
        raoMetadata.setRaoRequestInstant(getLastInstant(metadataMap.values().stream().map(CoreCCMetadata::getRaoRequestInstant).filter(Objects::nonNull).collect(Collectors.toSet())));
        return metadataMap;
    }

    // -------------------- MINIO UPLOADS ---------------

    private void zipAndUploadLogs(List<byte[]> logList, String logFileName) {
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
             ZipOutputStream zos = new ZipOutputStream(baos)) {
            for (byte[] bytes : logList) {
                ZipUtil.collectAndZip(zos, bytes);
            }
            zos.close();
            // upload zipped result
            uploadOfOutputToMinio(baos.toByteArray(), logFileName);
        } catch (IOException e) {
            throw new CoreCCPostProcessingInternalException("Error while unzipping logs", e);
        }
    }

    private void uploadOfOutputToMinio(byte[] outputBytes, String outputPath) {
        try (InputStream logZipIs = new ByteArrayInputStream(outputBytes)) {
            minioAdapter.uploadOutput(outputPath, logZipIs);
        } catch (IOException e) {
            throw new CoreCCPostProcessingInternalException(String.format("Error occured while uploading file %s to MinIO", outputPath), e);
        }
    }

    private void zipCgmsAndSendToOutputs(String targetMinioFolder, Map<TaskDto, ProcessFileDto> cgms, LocalDate localDate, String correlationId, String timeInterval) {
        try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {
            fillZipArchiveWithValidatedCgms(cgms, byteArrayOutputStream, localDate, correlationId, timeInterval);
            byte[] cgmArchiveBytes = byteArrayOutputStream.toByteArray();
            sendCgmsArchiveToOutputs(targetMinioFolder, localDate, cgmArchiveBytes);
        } catch (IOException e) {
            throw new CoreCCPostProcessingInternalException(String.format("Exception occurred while zipping CGMs of business day %s", localDate), e);
        }
    }

    private void fillZipArchiveWithValidatedCgms(Map<TaskDto, ProcessFileDto> cgms, ByteArrayOutputStream outputStream, LocalDate localDate, String correlationId, String timeInterval) {
        try (ZipOutputStream zipOutputStream = new ZipOutputStream(outputStream)) {
            cgms.values().stream().filter(processFileDto -> processFileDto.getProcessFileStatus().equals(ProcessFileStatus.VALIDATED)).forEach(cgm -> {
                LOGGER.info("Adding CGM {} to CGMs archive", cgm.getFilename());
                try (InputStream inputStream = minioAdapter.getFileFromFullPath(cgm.getFilePath())) {
                    zipOutputStream.putNextEntry(new ZipEntry(cgm.getFilename()));
                    zipOutputStream.write(inputStream.readAllBytes());
                    zipOutputStream.closeEntry();
                } catch (IOException e) {
                    throw new CoreCCPostProcessingInternalException(String.format("Error while filling CGMs archive with entry %s of MinIO", cgm.getFilePath()), e);
                }
            });
            zipOutputStream.putNextEntry(new ZipEntry(NamingRules.CGM_XML_HEADER_FILENAME));
            zipOutputStream.write(F305XmlGenerator.generateCgmXmlHeaderFile(cgms.keySet(), localDate, correlationId, timeInterval));
            zipOutputStream.closeEntry();
        } catch (IOException e) {
            throw new CoreCCPostProcessingInternalException("Error occured while creating CGMs archive", e);
        }
    }

    private void sendCgmsArchiveToOutputs(String targetMinioFolder, LocalDate localDate, byte[] cgmArchiveBytes) {
        String targetCgmZipName = NamingRules.generateCgmZipName(localDate);
        String targetCgmZipPath = NamingRules.generateOutputsDestinationPath(targetMinioFolder, targetCgmZipName);
        uploadOfOutputToMinio(cgmArchiveBytes, targetCgmZipPath);
    }

    private void zipCnesAndSendToOutputs(String targetMinioFolder, Map<TaskDto, ProcessFileDto> cnes, LocalDate localDate) {
        try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {
            fillZipArchiveWithValidatedCnes(cnes, byteArrayOutputStream);
            byte[] cneArchiveBytes = byteArrayOutputStream.toByteArray();
            sendCnesArchiveToOutputs(targetMinioFolder, localDate, cneArchiveBytes);
        } catch (IOException e) {
            throw new CoreCCPostProcessingInternalException(String.format("Exception occurred while zipping CNEs of business day %s", localDate), e);
        }
    }

    private void fillZipArchiveWithValidatedCnes(Map<TaskDto, ProcessFileDto> cnes, ByteArrayOutputStream outputStream) {
        try (ZipOutputStream zipOutputStream = new ZipOutputStream(outputStream)) {
            cnes.values().stream().filter(processFileDto -> processFileDto.getProcessFileStatus().equals(ProcessFileStatus.VALIDATED)).forEach(cne -> {
                LOGGER.info("Adding CNE {} to CNEs archive", cne.getFilename());
                try (InputStream inputStream = minioAdapter.getFileFromFullPath(cne.getFilePath())) {
                    zipOutputStream.putNextEntry(new ZipEntry(cne.getFilename()));
                    zipOutputStream.write(inputStream.readAllBytes());
                    zipOutputStream.closeEntry();
                } catch (IOException e) {
                    throw new CoreCCPostProcessingInternalException(String.format("Error while filling CNEs archive with entry %s of MinIO", cne.getFilePath()), e);
                }
            });
        } catch (IOException e) {
            throw new CoreCCPostProcessingInternalException("Error occured while creating CNEs archive", e);
        }
    }

    private void sendCnesArchiveToOutputs(String targetMinioFolder, LocalDate localDate, byte[] cneArchiveBytes) {
        String targetCneZipName = NamingRules.generateCneZipName(localDate);
        String targetCneZipPath = NamingRules.generateOutputsDestinationPath(targetMinioFolder, targetCneZipName);
        uploadOfOutputToMinio(cneArchiveBytes, targetCneZipPath);
    }

    void uploadF303ToMinio(FlowBasedConstraintDocument dailyFbDocument, String targetMinioFolder, LocalDate localDate) {
        byte[] dailyFbConstraint = JaxbUtil.writeInBytes(FlowBasedConstraintDocument.class, dailyFbDocument);
        String fbConstraintFileName = NamingRules.generateOptimizedCbFileName(localDate);
        String fbConstraintDestinationPath = NamingRules.generateOutputsDestinationPath(targetMinioFolder, fbConstraintFileName);
        uploadOfOutputToMinio(dailyFbConstraint, fbConstraintDestinationPath);
    }

    void uploadF341ToMinio(String targetMinioFolder, byte[] csv) {
        String metadataFileName = NamingRules.generateMetadataFileName(raoMetadata.getRaoRequestInstant(), raoMetadata.getVersion());
        String metadataDestinationPath = NamingRules.generateOutputsDestinationPath(targetMinioFolder, metadataFileName);
        uploadOfOutputToMinio(csv, metadataDestinationPath);
    }

    private void uploadF305ToMinio(String targetMinioFolder, ResponseMessageType responseMessage, LocalDate localDate) {
        byte[] responseMessageBytes = JaxbUtil.marshallMessageAndSetJaxbProperties(responseMessage);
        String f305FileName = NamingRules.generateRF305FileName(localDate);
        String f305DestinationPath = NamingRules.generateOutputsDestinationPath(targetMinioFolder, f305FileName);
        uploadOfOutputToMinio(responseMessageBytes, f305DestinationPath);
    }

    private void zipRaoResultsAndSendToOutputs(String targetMinioFolder, Map<TaskDto, ProcessFileDto> raoResults, LocalDate localDate) {
        try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {
            fillZipArchiveWithValidatedRaoResults(raoResults, byteArrayOutputStream);
            byte[] raoResultArchiveBytes = byteArrayOutputStream.toByteArray();
            sendRaoResultsArchiveToOutputs(targetMinioFolder, localDate, raoResultArchiveBytes);
        } catch (IOException e) {
            throw new CoreCCPostProcessingInternalException(String.format("Exception occurred while zipping RaoResults of business day %s", localDate), e);
        }
    }

    private void sendRaoResultsArchiveToOutputs(String targetMinioFolder, LocalDate localDate, byte[] raoResultArchiveBytes) {
        String targetRaoResultZipName = NamingRules.generateRaoResultFilename(localDate);
        String targetRaoResultZipPath = NamingRules.generateOutputsDestinationPath(targetMinioFolder, targetRaoResultZipName);
        uploadOfOutputToMinio(raoResultArchiveBytes, targetRaoResultZipPath);
    }

    private void fillZipArchiveWithValidatedRaoResults(Map<TaskDto, ProcessFileDto> raoResults, OutputStream outputStream) {
        try (ZipOutputStream zipOutputStream = new ZipOutputStream(outputStream)) {
            raoResults.values().stream().filter(processFileDto -> processFileDto.getProcessFileStatus().equals(ProcessFileStatus.VALIDATED)).forEach(raoResult -> {
                LOGGER.info("Adding RAO result {} to CASTOR internal results archive", raoResult.getFilename());
                try (InputStream inputStream = minioAdapter.getFileFromFullPath(raoResult.getFilePath())) {
                    zipOutputStream.putNextEntry(new ZipEntry(raoResult.getFilename()));
                    zipOutputStream.write(inputStream.readAllBytes());
                    zipOutputStream.closeEntry();
                } catch (IOException e) {
                    throw new CoreCCPostProcessingInternalException(String.format("Error while filling CASTOR internal results archive with entry %s of MinIO", raoResult.getFilePath()), e);
                }
            });
        } catch (IOException e) {
            throw new CoreCCPostProcessingInternalException("Error occured while creating CASTOR internal results archive", e);
        }
    }

}
