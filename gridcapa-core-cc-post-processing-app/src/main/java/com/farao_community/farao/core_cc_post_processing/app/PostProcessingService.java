/*
 * Copyright (c) 2023, RTE (http://www.rte-france.com)
 *  This Source Code Form is subject to the terms of the Mozilla Public
 *  License, v. 2.0. If a copy of the MPL was not distributed with this
 *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package com.farao_community.farao.core_cc_post_processing.app;

import com.farao_community.farao.core_cc_post_processing.app.exception.CoreCCPostProcessingInternalException;
import com.farao_community.farao.core_cc_post_processing.app.services.CoreCCMetadataGenerator;
import com.farao_community.farao.core_cc_post_processing.app.services.DailyF303Generator;
import com.farao_community.farao.core_cc_post_processing.app.services.RaoIXmlResponseGenerator;
import com.farao_community.farao.core_cc_post_processing.app.util.JaxbUtil;
import com.farao_community.farao.core_cc_post_processing.app.util.OutputFileNameUtil;
import com.farao_community.farao.core_cc_post_processing.app.util.RaoMetadata;
import com.farao_community.farao.core_cc_post_processing.app.util.ZipUtil;
import com.farao_community.farao.data.crac_creation.creator.fb_constraint.xsd.FlowBasedConstraintDocument;
import com.farao_community.farao.gridcapa.task_manager.api.ProcessFileDto;
import com.farao_community.farao.gridcapa.task_manager.api.ProcessFileStatus;
import com.farao_community.farao.gridcapa.task_manager.api.TaskDto;
import com.farao_community.farao.gridcapa_core_cc.api.resource.CoreCCMetadata;
import com.farao_community.farao.minio_adapter.starter.MinioAdapter;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.time.Instant;
import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;
import java.util.zip.ZipOutputStream;

import static com.farao_community.farao.core_cc_post_processing.app.util.RaoMetadata.*;

/**
 * @author Philippe Edwards {@literal <philippe.edwards at rte-france.com>}
 * @author Godelaine de Montmorillon {@literal <godelaine.demontmorillon at rte-france.com>}
 */
@Service
public class PostProcessingService {
    private static final Logger LOGGER = LoggerFactory.getLogger(PostProcessingService.class);
    public static final String CORE_CC = "CORE/CC/";
    private final MinioAdapter minioAdapter;
    private final RaoIXmlResponseGenerator raoIXmlResponseGenerator;
    private final DailyF303Generator dailyF303Generator;
    private RaoMetadata raoMetadata = new RaoMetadata();

    public PostProcessingService(MinioAdapter minioAdapter, RaoIXmlResponseGenerator raoIXmlResponseGenerator, DailyF303Generator dailyF303Generator) {
        this.minioAdapter = minioAdapter;
        this.raoIXmlResponseGenerator = raoIXmlResponseGenerator;
        this.dailyF303Generator = dailyF303Generator;
    }

    public void processTasks(LocalDate localDate, Set<TaskDto> tasksToPostProcess, List<byte[]> logList) {
        String outputsTargetMinioFolder = generateTargetMinioFolder(localDate);
        // Fetch hourly outputs generated by core-cc runner
        Map<TaskDto, ProcessFileDto> cnePerTask = new HashMap<>();
        Map<TaskDto, ProcessFileDto> cgmPerTask = new HashMap<>();
        Map<TaskDto, ProcessFileDto> metadataPerTask = new HashMap<>();
        fillMapsOfOutputs(tasksToPostProcess, cnePerTask, cgmPerTask, metadataPerTask);

        // Generate outputs
        // -- metadata file
        Map<UUID, CoreCCMetadata> metadataMap = fetchMetadataFromMinio(metadataPerTask);
        try {
            new CoreCCMetadataGenerator(minioAdapter).exportMetadataFile(outputsTargetMinioFolder, metadataMap.values().stream().collect(Collectors.toList()), raoMetadata);
        } catch (Exception e) {
            LOGGER.error("Could not generate metadata file for core cc : {}", e.getMessage());
            throw new CoreCCPostProcessingInternalException("Could not generate metadata file");
        }

        // -- zipped logs
        zipAndUploadLogs(logList, OutputFileNameUtil.generateZippedLogsName(raoMetadata.getRaoRequestInstant(), outputsTargetMinioFolder, raoMetadata.getVersion()));

        // -- cgms
        zipCgmsAndSendToOutputs(outputsTargetMinioFolder, cgmPerTask, localDate, raoMetadata.getCorrelationId());
        // -- cnes
        zipCnesAndSendToOutputs(outputsTargetMinioFolder, cnePerTask, localDate);
        // -- flowBasedConstraintDocument
        FlowBasedConstraintDocument dailyFlowBasedConstraintDocument = dailyF303Generator.generate(tasksToPostProcess);
        uploadDailyOutputFlowBasedConstraintDocument(dailyFlowBasedConstraintDocument, outputsTargetMinioFolder, localDate);
        // -- RaoResponse
        raoIXmlResponseGenerator.generateRaoResponse(tasksToPostProcess, outputsTargetMinioFolder, localDate, raoMetadata.getCorrelationId(), metadataMap); //f305 rao response
    }

    private String generateTargetMinioFolder(LocalDate localDate) {
        return "RAO_OUTPUTS_DIR/" + localDate;
    }

    private void fillMapsOfOutputs(Set<TaskDto> tasksToProcess,
                                   Map<TaskDto, ProcessFileDto> cnes,
                                   Map<TaskDto, ProcessFileDto> cgms,
                                   Map<TaskDto, ProcessFileDto> metadatas) {
        tasksToProcess.forEach(taskDto ->
            taskDto.getOutputs().forEach(processFileDto -> {
                switch (processFileDto.getFileType()) {
                    case "CNE":
                        cnes.put(taskDto, processFileDto);
                        break;
                    case "CGM_OUT":
                        cgms.put(taskDto, processFileDto);
                        break;
                    case "METADATA":
                        metadatas.put(taskDto, processFileDto);
                        break;
                    default:
                        // do nothing, other outputs are available but we won't be collecting them
                }
            })
        );
    }

    Map<UUID, CoreCCMetadata> fetchMetadataFromMinio(Map<TaskDto, ProcessFileDto> metadatas) {
        Map<UUID, CoreCCMetadata> metadataMap = new HashMap<>();
        metadatas.entrySet().stream().filter(md -> md.getValue().getProcessFileStatus().equals(ProcessFileStatus.VALIDATED)).
            forEach(metadata -> {
                // TODO : more robust way of fetching un-presigned url
                InputStream inputStream = minioAdapter.getFile(metadata.getValue().getFilePath().split(CORE_CC)[1]);
                try {
                    CoreCCMetadata coreCCMetadata = new ObjectMapper().readValue(IOUtils.toString(inputStream, StandardCharsets.UTF_8), CoreCCMetadata.class);
                    metadataMap.put(metadata.getKey().getId(), coreCCMetadata);
                } catch (IOException e) {
                    throw new CoreCCPostProcessingInternalException("error while fetching individual metadata", e);
                }
            });
        // Sanity checks
        if (metadataMap.values().stream().map(CoreCCMetadata::getTimeInterval).collect(Collectors.toSet()).size() > 1) {
            throw new CoreCCPostProcessingInternalException("Wrong time Interval in metadata");
        }
        if (metadataMap.values().stream().map(CoreCCMetadata::getRaoRequestFileName).collect(Collectors.toSet()).size() > 1) {
            throw new CoreCCPostProcessingInternalException("Wrong Rao request file name in metadata");
        }
        if (metadataMap.values().stream().map(CoreCCMetadata::getVersion).collect(Collectors.toSet()).size() > 1) {
            throw new CoreCCPostProcessingInternalException("Wrong version in metadata");
        }
        if (metadataMap.values().stream().map(CoreCCMetadata::getCorrelationId).collect(Collectors.toSet()).size() > 1) {
            throw new CoreCCPostProcessingInternalException("Wrong correlationId in metadata");
        }
        // Define raoMetadata attributes
        raoMetadata.setStatus(generateOverallStatus(metadataMap.values().stream().map(CoreCCMetadata::getStatus).collect(Collectors.toSet())));
        raoMetadata.setTimeInterval(metadataMap.values().stream().map(CoreCCMetadata::getTimeInterval).collect(Collectors.toSet()).iterator().next());
        raoMetadata.setRequestReceivedInstant(getFirstInstant(metadataMap.values().stream().map(CoreCCMetadata::getRequestReceivedInstant).collect(Collectors.toSet())));
        raoMetadata.setComputationStartInstant(getFirstInstant(metadataMap.values().stream().map(CoreCCMetadata::getComputationStart).collect(Collectors.toSet())));
        raoMetadata.setComputationEndInstant(getLastInstant(metadataMap.values().stream().map(CoreCCMetadata::getComputationEnd).collect(Collectors.toSet())));
        raoMetadata.setRaoRequestFileName(metadataMap.values().stream().map(CoreCCMetadata::getRaoRequestFileName).collect(Collectors.toSet()).iterator().next());
        raoMetadata.setVersion(metadataMap.values().stream().map(CoreCCMetadata::getVersion).collect(Collectors.toSet()).iterator().next());
        raoMetadata.setRaoRequestInstant(getLastInstant(metadataMap.values().stream().map(CoreCCMetadata::getRaoRequestInstant).collect(Collectors.toSet())));
        raoMetadata.setCorrelationId(metadataMap.values().stream().map(CoreCCMetadata::getCorrelationId).collect(Collectors.toSet()).iterator().next());
        raoMetadata.setOutputsSendingInstant(Instant.now().toString());

        return metadataMap;
    }

    private void zipAndUploadLogs(List<byte[]> logList, String logFileName) {
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
             ZipOutputStream zos = new ZipOutputStream(baos)) {
            for (byte[] bytes : logList) {
                ZipUtil.collectAndZip(zos, bytes);
            }
            // upload zipped result
            minioAdapter.uploadOutput(logFileName, new ByteArrayInputStream(baos.toByteArray()));
        } catch (IOException e) {
            throw new CoreCCPostProcessingInternalException("Error while unzipping logs", e);
        }
    }

    // TODO : verifier temporalite : intervalles etc. Difference d'objets : OffsetDateTime etc
    private void zipCgmsAndSendToOutputs(String targetMinioFolder, Map<TaskDto, ProcessFileDto> cgms, LocalDate localDate, String correlationId) {
        String cgmZipTmpDir = "/tmp/cgms_out/" + localDate.toString() + "/";
        // add cgm xml header to tmp folder
        raoIXmlResponseGenerator.generateCgmXmlHeaderFile(cgms.keySet(), cgmZipTmpDir, localDate, correlationId);

        // Add all cgms from minio to tmp folder
        cgms.values().stream().filter(processFileDto -> processFileDto.getProcessFileStatus().equals(ProcessFileStatus.VALIDATED)).forEach(cgm -> {
            InputStream inputStream = minioAdapter.getFile(cgm.getFilePath().split(CORE_CC)[1]);
            File cgmFile = new File(cgmZipTmpDir + cgm.getFilename());
            try {
                FileUtils.copyInputStreamToFile(inputStream, cgmFile);
            } catch (IOException e) {
                throw new CoreCCPostProcessingInternalException("error while copying cgm to tmp folder", e);
            }
        });

        // Zip tmp folder
        byte[] cgmsZipResult = ZipUtil.zipDirectory(cgmZipTmpDir);
        String targetCgmsFolderName = OutputFileNameUtil.generateCgmZipName(localDate);
        String targetCgmsFolderPath = OutputFileNameUtil.generateOutputsDestinationPath(targetMinioFolder, targetCgmsFolderName);

        try (InputStream cgmZipIs = new ByteArrayInputStream(cgmsZipResult)) {
            minioAdapter.uploadOutput(targetCgmsFolderPath, cgmZipIs);
        } catch (IOException e) {
            throw new CoreCCPostProcessingInternalException(String.format("Exception occurred while zipping CGMs of business day %s", localDate));
        } finally {
            ZipUtil.deletePath(Paths.get(cgmZipTmpDir)); //NOSONAR
        }

    }

    private void zipCnesAndSendToOutputs(String targetMinioFolder, Map<TaskDto, ProcessFileDto> cnes, LocalDate localDate) {
        String cneZipTmpDir = "/tmp/cnes_out/" + localDate.toString() + "/";

        // Add all cnes from minio to tmp folder
        cnes.values().stream()
            .filter(processFileDto -> processFileDto.getProcessFileStatus().equals(ProcessFileStatus.VALIDATED))
            .forEach(cne -> {
                InputStream inputStream = minioAdapter.getFile(cne.getFilePath().split(CORE_CC)[1]);
                File cneFile = new File(cneZipTmpDir + cne.getFilename());
                try {
                    FileUtils.copyInputStreamToFile(inputStream, cneFile);
                } catch (IOException e) {
                    throw new CoreCCPostProcessingInternalException("error while copying cne to tmp folder", e);
                }
            });

        byte[] cneZipResult = ZipUtil.zipDirectory(cneZipTmpDir);
        String targetCneFolderName = OutputFileNameUtil.generateCneZipName(localDate);
        String targetCneFolderPath = OutputFileNameUtil.generateOutputsDestinationPath(targetMinioFolder, targetCneFolderName);

        try (InputStream cneZipIs = new ByteArrayInputStream(cneZipResult)) {
            minioAdapter.uploadOutput(targetCneFolderPath, cneZipIs);
        } catch (IOException e) {
            throw new CoreCCPostProcessingInternalException(String.format("Exception occurred while zipping CNEs of business day %s", localDate));
        } finally {
            ZipUtil.deletePath(Paths.get(cneZipTmpDir)); //NOSONAR
        }
    }

    void uploadDailyOutputFlowBasedConstraintDocument(FlowBasedConstraintDocument dailyFbDocument, String targetMinioFolder, LocalDate localDate) {
        byte[] dailyFbConstraint = JaxbUtil.writeInBytes(FlowBasedConstraintDocument.class, dailyFbDocument);
        String fbConstraintFileName = OutputFileNameUtil.generateOptimizedCbFileName(localDate);
        String fbConstraintDestinationPath = OutputFileNameUtil.generateOutputsDestinationPath(targetMinioFolder, fbConstraintFileName);

        try (InputStream dailyFbIs = new ByteArrayInputStream(dailyFbConstraint)) {
            minioAdapter.uploadOutput(fbConstraintDestinationPath, dailyFbIs);
        } catch (IOException e) {
            throw new CoreCCPostProcessingInternalException(String.format("Exception occurred while uploading F303 file of business day %s", localDate));
        }
    }
}
